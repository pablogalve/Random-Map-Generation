# Procedural Map Generation
 
I am [Pablo Galve](https://www.linkedin.com/in/pablogalve), student of the
[Bachelor’s Degree in
Video Games Programming and Development](https://www.citm.upc.edu/ing/estudis/graus-videojocs/) by UPC at CITM). 

This content is generated for the second year’s subject Project 2, under supervision of lecturer
[Marc Garrigó](https://www.linkedin.com/in/mgarrigo).

## What are procedural generated maps?
Procedural maps are generated by a computer instead of by a person.

## Why to use procedural generated maps?
Manually created maps are limited to our budget (both in time and money). We can create awesome levels but we can't design an infinite map as it would consume endless production resources.   

What if we could create a different map in each game? What if we could have endless different combinations?
Well, we can do it with procedural map generation.
Let's see...

## Characteristics of a procedural generated map
### Pros and Cons of using them
#### Pros of procedural algorithms
- New challenges and experiences on each game.
- Users can play for years as it's a never ending different experience.
- Maps can be adjust its difficulty based on the player.
- Monetization can be dramatically increased.
#### Cons of procedural algorithms
- You can't design it 100% as you want, that's why narrative focused games don't use it.
- It takes time and resources to build.

### When is it useful to use procedural methodologies instead of doing maps manually?
Well, certainly we should use different methodologies depending on the project requirements.

* Manual
  * If it's a small game.
  * If it needs to follow a defined story/narrative.
  * If you need extreme details.
* Procedural
  * If it's an open-world game.
  * If you want endless different map combinations.
  * If you want every game to be unique.


It is usually used for creating the environment, spawning enemies or looting objects.
However, it can be used for anything as you could procedurally generate an entire universe.

We also have to take into account that these methodologies are not trully random but quasi-random and they use content generated beforehand by developers. The computed chooses where to allocate each element of even combine parts of elements to generate more complex objects or assets.

## Different approaches by different games
The most well-known game using procedural map generation is Minecraft by Mojang. 
Other games that have used procedural mothodologies for its entire maps or for some of its parts are Civilization V, Dwarf Fortress, Spore and Diablo

### Different algorithms
#### Binary space partitioning for Dungeons
This is probably one of the easiest methods to achieve procedural map generation for dungeons, but it's also really simple.

Firstly, we have an empty giant room that we'll use to create the map. We name that giant room 1.
We need to divide our available big room in different rooms using binary space partitioning.
Space sizes may be different for each space.
* We create childs 2 and 3 from parent 1.
* We create childs 4 and 5 from parent 2.
* We create childs 6 and 7 from parent 3.
* We create childs 8 and 9 from parent 5.
We divide until we can't divide anymore or until we reach a defined maximum number of spaces.
We'll get something like that:

<img src="https://github.com/pablogalve/Random-Map-Generation/blob/master/docs/Assets/Binary_space_partitioning_concept__01_dividing_space.PNG?raw=true" alt="Dividing Space" width="400" height="200">

Then, once we have the space divided we generate separated rooms inside each space.
In order to that we generate a room of the space' size but leaving a margin in order to leave some empty spaces without rooms.
For example, we can achieve that by giving a 10% margin between space wall and room wall.

<img src="https://github.com/pablogalve/Random-Map-Generation/blob/master/docs/Assets/Binary_space_partitioning_concept__02_rooms.PNG?raw=true" alt="Generate rooms" width="400" height="200">

Finally, we create corridors to connect all the rooms and make sure that the entire map is reachable.
In order to achieve that, we start with the youngest child and we connect chils from the same parent.
* 8 and 9
* 4 and 5. But 4 is composed by 8 and 9, so we create a corridor between 5 and (8 or 9, can be choosed randomly).
* 6 and 7
* 2 and 3. Both 2 and 3 are groups of rooms so we need to connect one room from each group.

<img src="https://github.com/pablogalve/Random-Map-Generation/blob/master/docs/Assets/Binary_space_partitioning_concept__03_corridors.PNG?raw=true" alt="Corridors" width="400" height="200">

And we could have a result like that:
<img src="https://github.com/pablogalve/Random-Map-Generation/blob/master/docs/Assets/dungeon.PNG?raw=true" alt="Dungeon" width="400" height="200">

#### Interpretive 
Used by Spore.

They generate creatures with interpretive methodologies.

<img src="https://github.com/pablogalve/Random-Map-Generation/blob/master/docs/Assets/Interpretive_spore_02.PNG?raw=true" alt="alt text" width="100" height="50">
<img src="https://github.com/pablogalve/Random-Map-Generation/blob/master/docs/Assets/Interpretive_motion.PNG?raw=true" alt="alt text" width="100" height="50">

#### Perlin Noise
We'll be using this method for this tutorial. Explained below.

## Perlin Noise Explained in Depth
Normal noise is what we could see in an out of sync TV.
Perlin noise is a smoother type of noise.
|![Normal noise](https://github.com/pablogalve/Random-Map-Generation/blob/master/docs/Assets/noise_normal.PNG?raw=true)|![Perlin noise](https://github.com/pablogalve/Random-Map-Generation/blob/master/docs/Assets/noise_perlin.PNG?raw=true)|
|:---:|:---:|
|Normal Noise|Perlin Noise|

We only need to store a seed and a math formula in order to procedurally generate an entire world as they are not located in a server but generated in real-time with your data.
What we do is introduce coordinates and our seed number, and the program will return as the output the map height at our desired coordinates. If we change the seed number, the generated world will be entirely different and unique.
<img src="https://github.com/pablogalve/Random-Map-Generation/blob/master/docs/Assets/height_formula.PNG?raw=true" alt="Height Formula" width="100" height="50">

## TODOs

## Theory on how to do Infinite Worlds
It could seem difficult to achieve, but it is not.
You should only need two things
- Occlusion Culling
- Generate Perlin Noise only for all the coordinates seen in screen

### Occlusion Culling
Neither computers nor servers can manage the computational power of storing an entire universe or world.
Well, some of them may be able to do it, but is really far from being efficient.
That's why you should render only what is on screen.
That way you save memory and prepare the program for generating an infinite world.

### Perlin Noise Generation
In our tutorial we limited the map from [100][100] to [100][100].
In order to make an infinite world you would need a height_map array that covers visible screen.
When you move the camera you have to unload the map areas that you are now not seeing and generate the new areas that you are exploring- 

# Bibliography
You can get more information here:

Video: ["Sunny Valley Studio" video series on youtube.](https://www.youtube.com/watch?v=VnqN0v95jtU)

Video: [The Happie Cat: How Procedurally Generated Terrain Works](https://www.youtube.com/watch?v=JdYkcrW8FBg)

Video: [Coding Challenge #10 2D Terrain Generation using Perlin Noise](https://www.youtube.com/watch?v=jv6YT9pPIHw)

I used [Fast c++ Noise Library by Jordan Peck](https://github.com/Auburns/FastNoise)

